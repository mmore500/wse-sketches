// layout parameters ==========================================================
///////////////////////////////////////////////////////////////////////////////
param peId: i16;
param x: i16;
param y: i16;
param ncycle: u16;
param nrow: i16;
param ncol: i16;
param memcpy_params: comptime_struct; // parameters for memcpy layout

// module imports =============================================================
///////////////////////////////////////////////////////////////////////////////
// memcpy module for copying data and launching functions from the host
const sys_mod = @import_module("<memcpy/memcpy>", memcpy_params);

const math = @import_module("<math>");
const random = @import_module("<random>");

// global output variables ====================================================
///////////////////////////////////////////////////////////////////////////////
var cycleCounter = @zeros([1]u16);
var ptr_cycleCounter : [*]u16 = &cycleCounter;

var recvCounter_N = @zeros([1]u16);
var ptr_recvCounter_N : [*]u16 = &recvCounter_N;
var recvCounter_S = @zeros([1]u16);
var ptr_recvCounter_S : [*]u16 = &recvCounter_S;
var recvCounter_E = @zeros([1]u16);
var ptr_recvCounter_E : [*]u16 = &recvCounter_E;
var recvCounter_W = @zeros([1]u16);
var ptr_recvCounter_W : [*]u16 = &recvCounter_W;

var sendCounter_N = @zeros([1]u16);
var ptr_sendCounter_N : [*]u16 = &sendCounter_N;
var sendCounter_S = @zeros([1]u16);
var ptr_sendCounter_S : [*]u16 = &sendCounter_S;
var sendCounter_E = @zeros([1]u16);
var ptr_sendCounter_E : [*]u16 = &sendCounter_E;
var sendCounter_W = @zeros([1]u16);
var ptr_sendCounter_W : [*]u16 = &sendCounter_W;

var genome = @zeros([1]f32);
var ptr_genome : [*]f32 = &genome;

var whoami = @zeros([1]i16);
var ptr_whoami : [*]i16 = &whoami;

var whereami_x = @zeros([1]i16);
var ptr_whereami_x : [*]i16 = &whereami_x;

var whereami_y = @zeros([1]i16);
var ptr_whereami_y : [*]i16 = &whereami_y;

const popSize: u16 = 64;
var population = @zeros([popSize]f32);
const populationDsd = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{1} -> population[i]
});
var ptr_population: [*]f32 = &population;

// task IDs ===================================================================
///////////////////////////////////////////////////////////////////////////////
const sendColor_N: color = @get_color(0);
const recvColor_S: color = @get_color(1);
const sendColor_E: color = @get_color(2);
const recvColor_W: color = @get_color(3);

const recvColor_N: color = @get_color(4);
const sendColor_S: color = @get_color(5);
const recvColor_E: color = @get_color(6);
const sendColor_W: color = @get_color(7);

const cycleColor: color = @get_color(8);
const cycleTaskID: data_task_id = @get_data_task_id(cycleColor);

const sendFinalizeTaskID_N: local_task_id = @get_local_task_id(14);
const sendFinalizeTaskID_S: local_task_id = @get_local_task_id(15);
const sendFinalizeTaskID_E: local_task_id = @get_local_task_id(16);
const sendFinalizeTaskID_W: local_task_id = @get_local_task_id(17);

const recvFinalizeTaskID_N: local_task_id = @get_local_task_id(10);
const recvFinalizeTaskID_S: local_task_id = @get_local_task_id(11);
const recvFinalizeTaskID_E: local_task_id = @get_local_task_id(12);
const recvFinalizeTaskID_W: local_task_id = @get_local_task_id(13);

// queue IDs ==================================================================
///////////////////////////////////////////////////////////////////////////////
const q_out_N: i16 = 0;
const q_out_S: i16 = 3;
const q_out_E: i16 = 2;
const q_out_W: i16 = 1;

const q_in_N: i16 = 7;
const q_in_S: i16 = 6;
const q_in_E: i16 = 5;
const q_in_W: i16 = 4;

///////////////////////////////////////////////////////////////////////////////
// ============================================================================
// send tasks
// ============================================================================
///////////////////////////////////////////////////////////////////////////////
const sendBufSize: u16 = popSize;
const sendNum: u16 = 2;

// send NORTH =================================================================
var sendBuf_N = @zeros([sendBufSize]f32); var sendFlag_N: u8 = 1;
const sendBufDsd_N = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{sendNum} -> sendBuf_N[i]
});

task sendFinalizeTask_N() void { sendFlag_N = 1; sendCounter_N[0] += 1; }

const sendDsd_N = @get_dsd(fabout_dsd, .{
  .extent = sendNum, .fabric_color = sendColor_N,
  .output_queue = @get_output_queue(q_out_N)
});
fn sendTask_N() void {
  @fmovs(
    sendDsd_N, sendBufDsd_N,
    .{
      .async = true,
      .activate = sendFinalizeTaskID_N,
      .priority = .{ .high = true }
    }
  );
  sendCounter_N[0] += 1;
}

// send SOUTH =================================================================
var sendBuf_S = @zeros([sendBufSize]f32); var sendFlag_S: u8 = 1;
const sendBufDsd_S = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{sendNum} -> sendBuf_S[i]
});

task sendFinalizeTask_S() void { sendFlag_S = 1; sendCounter_S[0] += 1; }

const sendDsd_S = @get_dsd(fabout_dsd, .{
  .extent = sendNum, .fabric_color = sendColor_S,
  .output_queue = @get_output_queue(q_out_S)
});
fn sendTask_S() void {
  @fmovs(
    sendDsd_S, sendBufDsd_S,
    .{
      .async = true,
      .activate = sendFinalizeTaskID_S,
      .priority = .{ .high = true }
    }
  );
  sendCounter_S[0] += 1;
}

// send EAST =================================================================
var sendBuf_E = @zeros([sendBufSize]f32); var sendFlag_E: u8 = 1;
const sendBufDsd_E = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{sendNum} -> sendBuf_E[i]
});

task sendFinalizeTask_E() void { sendFlag_E = 1; sendCounter_E[0] += 1; }

const sendDsd_E = @get_dsd(fabout_dsd, .{
  .extent = sendNum, .fabric_color = sendColor_E,
  .output_queue = @get_output_queue(q_out_E)
});
fn sendTask_E() void {
  @fmovs(
    sendDsd_E, sendBufDsd_E,
    .{
      .async = true,
      .activate = sendFinalizeTaskID_E,
      .priority = .{ .high = true }
    }
  );
  sendCounter_E[0] += 1;
}

// send WEST =================================================================
var sendBuf_W = @zeros([sendBufSize]f32); var sendFlag_W: u8 = 1;
const sendBufDsd_W = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{sendNum} -> sendBuf_W[i]
});

task sendFinalizeTask_W() void { sendFlag_W = 1; sendCounter_W[0] += 1; }

const sendDsd_W = @get_dsd(fabout_dsd, .{
  .extent = sendNum, .fabric_color = sendColor_W,
  .output_queue = @get_output_queue(q_out_W)
});
fn sendTask_W() void {
  @fmovs(
    sendDsd_W, sendBufDsd_W,
    .{
      .async = true,
      .activate = sendFinalizeTaskID_W,
      .priority = .{ .high = true }
    }
  );
  sendCounter_W[0] += 1;
}

// recv task ==================================================================
///////////////////////////////////////////////////////////////////////////////
const recvBufSize: u16 = 4;

// recv NORTH =================================================================
var recvBuf_N = @zeros([recvBufSize]f32); var recvFlag_N: u8 = 0;
const recvBufDsd_N = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{recvBufSize} -> recvBuf_N[i]
});

task recvFinalizeTask_N() void { recvFlag_N = 1; recvCounter_N[0] += 1; }

const recvDsd_N = @get_dsd(fabin_dsd, .{
  .fabric_color = recvColor_N,
  .extent = recvBufSize,
  .input_queue = @get_input_queue(q_in_N)
});
fn recvTask_N() void {
  @fmovs(
    recvBufDsd_N, recvDsd_N,
    .{
      .async = true,
      .activate = recvFinalizeTaskID_N,
      // .priority = .{ .high = true }
    },
  );
  recvCounter_N[0] += 1;
}

// recv SOUTH =================================================================
var recvBuf_S = @zeros([recvBufSize]f32); var recvFlag_S: u8 = 0;
const recvBufDsd_S = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{recvBufSize} -> recvBuf_S[i]
});

task recvFinalizeTask_S() void { recvFlag_S = 1; recvCounter_S[0] += 1; }

const recvDsd_S = @get_dsd(fabin_dsd, .{
  .fabric_color = recvColor_S,
  .extent = recvBufSize,
  .input_queue = @get_input_queue(q_in_S)
});
fn recvTask_S() void {
  @fmovs(
    recvBufDsd_S, recvDsd_S,
    .{
      .async = true,
      .activate = recvFinalizeTaskID_S,
      .priority = .{ .high = true }
    },
  );
  recvCounter_S[0] += 1;
}

// recv EAST ==================================================================
var recvBuf_E = @zeros([recvBufSize]f32); var recvFlag_E: u8 = 0;
const recvBufDsd_E = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{recvBufSize} -> recvBuf_E[i]
});

task recvFinalizeTask_E() void { recvFlag_E = 1; recvCounter_E[0] += 1; }

const recvDsd_E = @get_dsd(fabin_dsd, .{
  .fabric_color = recvColor_E,
  .extent = recvBufSize,
  .input_queue = @get_input_queue(q_in_E)
});
fn recvTask_E() void {
  @fmovs(
    recvBufDsd_E, recvDsd_E,
    .{
      .async = true,
      .activate = recvFinalizeTaskID_E,
      .priority = .{ .high = true }
    },
  );
  recvCounter_E[0] += 1;
}

// recv WEST ==================================================================
var recvBuf_W = @zeros([recvBufSize]f32); var recvFlag_W: u8 = 0;
const recvBufDsd_W = @get_dsd(mem1d_dsd, .{
  .tensor_access = |i|{recvBufSize} -> recvBuf_W[i]
});

task recvFinalizeTask_W() void { recvFlag_W = 1; recvCounter_W[0] += 1; }

const recvDsd_W = @get_dsd(fabin_dsd, .{
  .fabric_color = recvColor_W,
  .extent = recvBufSize,
  .input_queue = @get_input_queue(q_in_W)
});
fn recvTask_W() void {
  @fmovs(
    recvBufDsd_W, recvDsd_W,
    .{
      .async = true,
      .activate = recvFinalizeTaskID_W,
      .priority = .{ .high = true }
    },
  );
  recvCounter_W[0] += 1;
}

// cycle task =================================================================
///////////////////////////////////////////////////////////////////////////////

const cycleDsd = @get_dsd(fabout_dsd, .{
    .extent = 1,
    .fabric_color = cycleColor,
  }
);

fn integrate(genome_: f32) void {
    const target = @as(u16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= target and target < popSize);  // makes slow
    population[target] = math.max(population[target], genome_);
}

// self-activate with incrementing values
// until threshold reached
task cycleTask(data: u16) void {

  const iseven: bool = @as(bool, data % 2 == 0);

  // handle recv flags
  if (@as(bool, recvFlag_N)) {
    @map(integrate, recvBufDsd_N);
    recvFlag_N = 0;
    recvTask_N();
  }
  if (@as(bool, recvFlag_S)) {
    @map(integrate, recvBufDsd_S);
    recvFlag_S = 0;
    recvTask_S();
  }
  if (@as(bool, recvFlag_E)) {
    @map(integrate, recvBufDsd_E);
    recvFlag_E = 0;
    recvTask_E();
  }
  if (@as(bool, recvFlag_W)) {
    @map(integrate, recvBufDsd_W);
    recvFlag_W = 0;
    recvTask_W();
  }

  // generational turnover
  for (@range(u16, 32)) |tournament| {
    const parent1 = @as(i16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= parent1 and parent1 < popSize);  // makes slow
    const parent2 = @as(i16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= parent2 and parent2 < popSize); // makes slow

    const offspring1: f32 = population[parent1] + random.random_normal_f32();
    const offspring2: f32 = population[parent2] + random.random_normal_f32();

    const target = @as(i16, random.random_f16(0.0, @as(f16, popSize)));
    // @assert(0 <= target and target < popSize); // makes slow
    population[target] = math.max(offspring1, offspring2);
  }
  genome[0] = population[0];

  // handle send flags
  if (iseven and @as(bool, sendFlag_N)) {
    @fmovs(sendBufDsd_N, populationDsd);
    sendFlag_N = 0;
    // except top row of PE array
    if (y != 0) sendTask_N();
  }
  if (!iseven and @as(bool, sendFlag_S)) {
    @fmovs(sendBufDsd_S, populationDsd);
    sendFlag_S = 0;
    // except bottom row of PE array
    if (y != nrow - 1) sendTask_S();
  }
  if (iseven and @as(bool, sendFlag_E)) {
    @fmovs(sendBufDsd_E, populationDsd);
    sendFlag_E = 0;
    // except right col of PE array
    if (x != ncol - 1) sendTask_E();
  }
  if (!iseven and @as(bool, sendFlag_W)) {
    @fmovs(sendBufDsd_W, populationDsd);
    sendFlag_W = 0;
    // except left col of PE array
    if (x != 0) sendTask_W();
  }

  if (data < ncycle) {
    const next: u16 = data + 1;
    @mov16(cycleDsd, next);
  } else {
    sys_mod.unblock_cmd_stream();
  }
  cycleCounter[0] = data;
}

// launcher ===================================================================
///////////////////////////////////////////////////////////////////////////////

fn dolaunch() void { // launched by RPC
  whoami[0] = peId;
  whereami_x[0] = x;
  whereami_y[0] = y;
  random.set_global_prng_seed(peId);
  recvTask_N();
  recvTask_S();
  recvTask_E();
  recvTask_W();
  @mov16(cycleDsd, 0);
}

// bind tasks =================================================================
///////////////////////////////////////////////////////////////////////////////
comptime {
  @bind_local_task(sendFinalizeTask_N, sendFinalizeTaskID_N);
  @bind_local_task(sendFinalizeTask_S, sendFinalizeTaskID_S);
  @bind_local_task(sendFinalizeTask_E, sendFinalizeTaskID_E);
  @bind_local_task(sendFinalizeTask_W, sendFinalizeTaskID_W);
  @bind_local_task(recvFinalizeTask_N, recvFinalizeTaskID_N);
  @bind_local_task(recvFinalizeTask_S, recvFinalizeTaskID_S);
  @bind_local_task(recvFinalizeTask_E, recvFinalizeTaskID_E);
  @bind_local_task(recvFinalizeTask_W, recvFinalizeTaskID_W);
  @bind_data_task(cycleTask, cycleTaskID);
}

// wavlet routing =============================================================
///////////////////////////////////////////////////////////////////////////////
comptime {
  @set_local_color_config(
    cycleColor,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ RAMP } } },
  );

  @set_local_color_config(
    sendColor_N,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ NORTH }, .color_swap_y = true } },
  );
  @set_local_color_config(
    sendColor_S,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ SOUTH }, .color_swap_y = true } },
  );
  @set_local_color_config(
    recvColor_N,
    .{ .routes = .{ .rx = .{ NORTH }, .tx = .{ RAMP }, .color_swap_y = true } },
  );
  @set_local_color_config(
    recvColor_S,
    .{ .routes = .{ .rx = .{ SOUTH }, .tx = .{ RAMP }, .color_swap_y = true } },
  );

  @set_local_color_config(
    sendColor_E,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ EAST }, .color_swap_x = true } },
  );
  @set_local_color_config(
    sendColor_W,
    .{ .routes = .{ .rx = .{ RAMP }, .tx = .{ WEST }, .color_swap_x = true } },
  );
  @set_local_color_config(
    recvColor_E,
    .{ .routes = .{ .rx = .{ EAST }, .tx = .{ RAMP }, .color_swap_x = true } },
  );
  @set_local_color_config(
    recvColor_W,
    .{ .routes = .{ .rx = .{ WEST }, .tx = .{ RAMP }, .color_swap_x = true } },
  );
}

// symbol exports =============================================================
///////////////////////////////////////////////////////////////////////////////
comptime {
  @export_symbol(ptr_cycleCounter, "cycleCounter");
  @export_symbol(ptr_recvCounter_N, "recvCounter_N");
  @export_symbol(ptr_recvCounter_S, "recvCounter_S");
  @export_symbol(ptr_recvCounter_E, "recvCounter_E");
  @export_symbol(ptr_recvCounter_W, "recvCounter_W");
  @export_symbol(ptr_sendCounter_N, "sendCounter_N");
  @export_symbol(ptr_sendCounter_S, "sendCounter_S");
  @export_symbol(ptr_sendCounter_E, "sendCounter_E");
  @export_symbol(ptr_sendCounter_W, "sendCounter_W");
  @export_symbol(ptr_genome, "genome");
  @export_symbol(ptr_population, "population");
  @export_symbol(ptr_whoami, "whoami");
  @export_symbol(ptr_whereami_x, "whereami_x");
  @export_symbol(ptr_whereami_y, "whereami_y");
  @export_symbol(dolaunch);

  @rpc(@get_data_task_id(sys_mod.LAUNCH)); // direct remote procedure calls
}
