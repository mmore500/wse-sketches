const tilted = @import_module("cerebraslib/tilted.csl");
const hanoi = @import_module("cerebraslib/hanoi.csl");
const math = @import_module("<math>");

fn test_get_reservation_position_physical() void {
    // Test for surface size 4

    const expected4 = [2]u32{0, 3};
    for (expected4) |v, i| {
        const j: u32 = @as(u32, i);
        const value: u32 = @as(u32, v);
        const result: u32 = tilted.get_reservation_position_physical(j, 4);
        @assert(result == value);
    }

    // Test for surface size 8
    const expected8 = [4]u32{ 0, 4, 5, 7 };
    for (expected8) |v, i| {
        const j: u32 = @as(u32, i);
        const value: u32 = @as(u32, v);
        const result: u32 = tilted.get_reservation_position_physical(j, 8);
        @assert(value == result);
    }

    // Test for surface size 16
    const expected16 = [8]u32{ 0, 5, 6, 8, 9, 12, 13, 15 };
    for (expected16) |v, i| {
        const j: u32 = @as(u32, i);
        const value: u32 = @as(u32, v);
        const result: u32 = tilted.get_reservation_position_physical(j, 16);
        @assert(value == result);
    }

    // Test for surface size 32
    const expected32 = [16]u32{ 0, 6, 7, 9, 10, 13, 14, 16, 17, 21, 22, 24, 25, 28, 29, 31 };
    for (expected32) |v, i| {
        const j: u32 = @as(u32, i);
        const value: u32 = @as(u32, v);
        const result: u32 = tilted.get_reservation_position_physical(j, 32);
        @assert(value == result);
    }

    // Test for surface size 64 with specific checks
    @assert(tilted.get_reservation_position_physical(0, 64) == 0);
    @assert(tilted.get_reservation_position_physical(16, 64) == 33);
    @assert(tilted.get_reservation_position_physical(31, 64) == 63);

    // Test all values for surface size 64 are increasing
    const rpp: u32 = tilted.get_reservation_position_physical(0, 64);
    var prevResult: u32 = tilted.get_reservation_position_physical(0, 64);

    for (@range(u32, 1, 32, 1)) |i| {
        const result: u32 = tilted.get_reservation_position_physical(i, 64);
        @assert(result > prevResult);
        prevResult = result;
    }
}

fn test_get_reservation_position_logical() void {
  @assert(tilted.get_reservation_position_logical(0, 4) == 0);
  @assert(tilted.get_reservation_position_logical(1, 4) == 3);

  @assert(tilted.get_reservation_position_logical(0, 8) == 0);
  @assert(tilted.get_reservation_position_logical(1, 8) ==  5);
  @assert(tilted.get_reservation_position_logical(2, 8) ==  4);
  @assert(tilted.get_reservation_position_logical(3, 8) == 7);

  @assert(tilted.get_reservation_position_logical(0, 16) == 0);
  @assert(tilted.get_reservation_position_logical(1, 16) == 9);
  @assert(tilted.get_reservation_position_logical(2, 16) == 6);
  @assert(tilted.get_reservation_position_logical(3, 16) == 13);
  @assert(tilted.get_reservation_position_logical(4, 16) == 5);
  @assert(tilted.get_reservation_position_logical(5, 16) == 8);
  @assert(tilted.get_reservation_position_logical(6, 16) == 12);
  @assert(tilted.get_reservation_position_logical(7, 16) == 15);

  @assert(tilted.get_reservation_position_logical(0, 32) == 0);
  @assert(tilted.get_reservation_position_logical(1, 32) == 17);
  @assert(tilted.get_reservation_position_logical(2, 32) == 10);
  @assert(tilted.get_reservation_position_logical(3, 32) == 25);
  @assert(tilted.get_reservation_position_logical(4, 32) == 7);
  @assert(tilted.get_reservation_position_logical(5, 32) == 14);
  @assert(tilted.get_reservation_position_logical(6, 32) == 22);
  @assert(tilted.get_reservation_position_logical(7, 32) == 29);
  @assert(tilted.get_reservation_position_logical(8, 32) == 6);
  @assert(tilted.get_reservation_position_logical(9, 32) == 9);
  @assert(tilted.get_reservation_position_logical(10, 32) == 13);
  @assert(tilted.get_reservation_position_logical(11, 32) == 16);
  @assert(tilted.get_reservation_position_logical(12, 32) == 21);
  @assert(tilted.get_reservation_position_logical(13, 32) == 24);
  @assert(tilted.get_reservation_position_logical(14, 32) == 28);
  @assert(tilted.get_reservation_position_logical(15, 32) == 31);
}

fn gge_expected(rank: u32, surface_size: u32) u32 {
    if (surface_size == 8) {
        if (rank < hanoi.get_hanoi_value_index_offset(3)) return 0;
        if (rank < hanoi.get_hanoi_value_index_offset(4)) return 1;
        return 2;
    } else if (surface_size == 16) {
        if (rank < hanoi.get_hanoi_value_index_offset(4)) return 0;
        if (rank < hanoi.get_hanoi_value_index_offset(5)) return 1;
        if (rank < hanoi.get_hanoi_value_index_offset(8)) return 2;
        return 3;
    } else if (surface_size == 32) {
        if (rank < hanoi.get_hanoi_value_index_offset(5)) return 0;
        if (rank < hanoi.get_hanoi_value_index_offset(6)) return 1;
        if (rank < hanoi.get_hanoi_value_index_offset(9)) return 2;
        if (rank < hanoi.get_hanoi_value_index_offset(16)) return 3;
        return 4;
    } else if (surface_size == 64) {
        if (rank < hanoi.get_hanoi_value_index_offset(6)) return 0;
        if (rank < hanoi.get_hanoi_value_index_offset(7)) return 1;
        if (rank < hanoi.get_hanoi_value_index_offset(10)) return 2;
        if (rank < hanoi.get_hanoi_value_index_offset(17)) return 3;
        if (rank < hanoi.get_hanoi_value_index_offset(32)) return 4;
        return 5;
    } else {
        @assert(false);
        return 1;
    }
}

fn test_get_global_epoch() void {
    const surface_sizes = [1]u32{8};

    for (surface_sizes) |size| {
        // Use a smaller range for testing to avoid excessive test durations
        const lb = @as(u32, 0);
        const ub = math.min(@as(u32, 4096), @as(u32, 1) << @as(u32, size));
        for (@range(u32, lb, ub, 1)) |rank| {
            const expected_epoch = gge_expected(rank, size);
            const actual_epoch = tilted.get_global_epoch(rank, size);
            @assert(expected_epoch == actual_epoch);
        }
    }
}

fn ggnr_expected(rank: u32, surface_size: u32) u32 {
    if (surface_size == 8) {
        if (rank < hanoi.get_hanoi_value_index_offset(3)) return 4;
        if (rank < hanoi.get_hanoi_value_index_offset(4)) return 2;
        return 1;
    } else if (surface_size == 16) {
        if (rank < hanoi.get_hanoi_value_index_offset(4)) return 8;
        if (rank < hanoi.get_hanoi_value_index_offset(5)) return 4;
        if (rank < hanoi.get_hanoi_value_index_offset(8)) return 2;
        return 1;
    } else if (surface_size == 32) {
        if (rank < hanoi.get_hanoi_value_index_offset(5)) return 16;
        if (rank < hanoi.get_hanoi_value_index_offset(6)) return 8;
        if (rank < hanoi.get_hanoi_value_index_offset(9)) return 4;
        if (rank < hanoi.get_hanoi_value_index_offset(16)) return 2;
        return 1;
    } else if (surface_size == 64) {
        if (rank < hanoi.get_hanoi_value_index_offset(6)) return 32;
        if (rank < hanoi.get_hanoi_value_index_offset(7)) return 16;
        if (rank < hanoi.get_hanoi_value_index_offset(10)) return 8;
        if (rank < hanoi.get_hanoi_value_index_offset(17)) return 4;
        if (rank < hanoi.get_hanoi_value_index_offset(32)) return 2;
        return 1;
    } else {
        @assert(false);
        return 1;
    }
}

fn test_get_global_num_reservations_at_epoch() void {
    const surface_sizes = [1]u32{8};

    for (surface_sizes) |size| {
        const lb: u32 = @as(u32, 0);
        const ub: u32 = math.min(@as(u32, 4096), @as(u32, 1) << @as(u32, size));
        for (@range(u32, lb, ub, 1)) |rank| {
            const epoch: u32 = tilted.get_global_epoch(rank, size);
            const expected = ggnr_expected(rank, size);
            const actual = tilted.get_global_num_reservations_at_epoch(epoch, size);
            @assert(expected == actual);
        }
    }
}



fn do_test() void {
  test_get_reservation_position_physical();
  test_get_reservation_position_logical();
  test_get_global_epoch();
  test_get_global_num_reservations_at_epoch();
}

